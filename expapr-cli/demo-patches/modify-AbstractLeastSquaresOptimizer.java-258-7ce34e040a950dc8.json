{
 "manifest_version": 3,
 "interface": "defects4j",
 "bug": "Math-65",
 "filename": "src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java",
 "context_above": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.optimization.general;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MaxEvaluationsExceededException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\nimport org.apache.commons.math.analysis.MultivariateMatrixFunction;\nimport org.apache.commons.math.exception.LocalizedFormats;\nimport org.apache.commons.math.linear.InvalidMatrixException;\nimport org.apache.commons.math.linear.LUDecompositionImpl;\nimport org.apache.commons.math.linear.MatrixUtils;\nimport org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.SimpleVectorialValueChecker;\nimport org.apache.commons.math.optimization.VectorialConvergenceChecker;\nimport org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\nimport org.apache.commons.math.optimization.VectorialPointValuePair;\n\n/**\n * Base class for implementing least squares optimizers.\n * <p>This base class handles the boilerplate methods associated to thresholds\n * settings, jacobian and error estimation.</p>\n * @version $Revision$ $Date$\n * @since 1.2\n *\n */\npublic abstract class AbstractLeastSquaresOptimizer implements DifferentiableMultivariateVectorialOptimizer {\n\n    /** Default maximal number of iterations allowed. */\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    /** Convergence checker. */\n    protected VectorialConvergenceChecker checker;\n\n    /**\n     * Jacobian matrix.\n     * <p>This matrix is in canonical form just after the calls to\n     * {@link #updateJacobian()}, but may be modified by the solver\n     * in the derived class (the {@link LevenbergMarquardtOptimizer\n     * Levenberg-Marquardt optimizer} does this).</p>\n     */\n    protected double[][] jacobian;\n\n    /** Number of columns of the jacobian matrix. */\n    protected int cols;\n\n    /** Number of rows of the jacobian matrix. */\n    protected int rows;\n\n    /**\n     * Target value for the objective functions at optimum.\n     * @since 2.1\n     */\n    protected double[] targetValues;\n\n    /**\n     * Weight for the least squares cost computation.\n     * @since 2.1\n     */\n    protected double[] residualsWeights;\n\n    /** Current point. */\n    protected double[] point;\n\n    /** Current objective function value. */\n    protected double[] objective;\n\n    /** Current residuals. */\n    protected double[] residuals;\n\n    /** Cost value (square root of the sum of the residuals). */\n    protected double cost;\n\n    /** Maximal number of iterations allowed. */\n    private int maxIterations;\n\n    /** Number of iterations already performed. */\n    private int iterations;\n\n    /** Maximal number of evaluations allowed. */\n    private int maxEvaluations;\n\n    /** Number of evaluations already performed. */\n    private int objectiveEvaluations;\n\n    /** Number of jacobian evaluations. */\n    private int jacobianEvaluations;\n\n    /** Objective function. */\n    private DifferentiableMultivariateVectorialFunction function;\n\n    /** Objective function derivatives. */\n    private MultivariateMatrixFunction jF;\n\n    /** Simple constructor with default settings.\n     * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n     * and the maximal number of evaluation is set to its default value.</p>\n     */\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new SimpleVectorialValueChecker());\n        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n\n    /** {@inheritDoc} */\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    /** {@inheritDoc} */\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    /** {@inheritDoc} */\n    public int getIterations() {\n        return iterations;\n    }\n\n    /** {@inheritDoc} */\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    /** {@inheritDoc} */\n    public VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    /** Increment the iterations counter by 1.\n     * @exception OptimizationException if the maximal number\n     * of iterations is exceeded\n     */\n    protected void incrementIterationsCounter()\n        throws OptimizationException {\n        if (++iterations > maxIterations) {\n            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    /**\n     * Update the jacobian matrix.\n     * @exception FunctionEvaluationException if the function jacobian\n     * cannot be evaluated or its dimension doesn't match problem dimension\n     */\n    protected void updateJacobian() throws FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    /**\n     * Update the residuals array and cost function value.\n     * @exception FunctionEvaluationException if the function cannot be evaluated\n     * or its dimension doesn't match problem dimension or maximal number of\n     * of evaluations is exceeded\n     */\n    protected void updateResidualsAndCost()\n        throws FunctionEvaluationException {\n\n        if (++objectiveEvaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                                  objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += residualsWeights[i] * residual * residual;\n            index += cols;\n        }\n        cost = Math.sqrt(cost);\n\n    }\n\n    /**\n     * Get the Root Mean Square value.\n     * Get the Root Mean Square value, i.e. the root of the arithmetic\n     * mean of the square of all weighted residuals. This is related to the\n     * criterion that is minimized by the optimizer as follows: if\n     * <em>c</em> if the criterion, and <em>n</em> is the number of\n     * measurements, then the RMS is <em>sqrt (c/n)</em>.\n     *\n     * @return RMS value\n     */\n    public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += residual * residual * residualsWeights[i];\n        }\n        return Math.sqrt(criterion / rows);\n    }\n\n    /**\n     * Get a Chi-Square-like value assuming the N residuals follow N\n     * distinct normal distributions centered on 0 and whose variances are\n     * the reciprocal of the weights.\n     * @return chi-square value\n     */\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            ",
 "context_below": ";\n        }\n        return chiSquare;\n    }\n\n    /**\n     * Get the covariance matrix of optimized parameters.\n     * @return covariance matrix\n     * @exception FunctionEvaluationException if the function jacobian cannot\n     * be evaluated\n     * @exception OptimizationException if the covariance matrix\n     * cannot be computed (singular problem)\n     */\n    public double[][] getCovariances()\n        throws FunctionEvaluationException, OptimizationException {\n\n        // set up the jacobian\n        updateJacobian();\n\n        // compute transpose(J).J, avoiding building big intermediate matrices\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n\n        try {\n            // compute the covariances matrix\n            RealMatrix inverse =\n                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (InvalidMatrixException ime) {\n            throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n\n    }\n\n    /**\n     * Guess the errors in optimized parameters.\n     * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n     * @return errors in optimized parameters\n     * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\n     * @exception OptimizationException if the covariances matrix cannot be computed\n     * or the number of degrees of freedom is not positive (number of measurements\n     * lesser or equal to number of parameters)\n     */\n    public double[] guessParametersErrors()\n        throws FunctionEvaluationException, OptimizationException {\n        if (rows <= cols) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                    rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    /** {@inheritDoc} */\n    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                            final double[] target, final double[] weights,\n                                            final double[] startPoint)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        if (target.length != weights.length) {\n            throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                                            target.length, weights.length);\n        }\n\n        // reset counters\n        iterations           = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations  = 0;\n\n        // store least squares problem characteristics\n        function         = f;\n        jF               = f.jacobian();\n        targetValues     = target.clone();\n        residualsWeights = weights.clone();\n        this.point       = startPoint.clone();\n        this.residuals   = new double[target.length];\n\n        // arrays shared with the other private methods\n        rows      = target.length;\n        cols      = point.length;\n        jacobian  = new double[rows][cols];\n\n        cost = Double.POSITIVE_INFINITY;\n\n        return doOptimize();\n\n    }\n\n    /** Perform the bulk of optimization algorithm.\n     * @return the point/value pair giving the optimal value for objective function\n     * @exception FunctionEvaluationException if the objective function throws one during\n     * the search\n     * @exception OptimizationException if the algorithm failed to converge\n     * @exception IllegalArgumentException if the start point dimension is wrong\n     */\n    protected abstract VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n\n}",
 "unpatched": "chiSquare += residual * residual / residualsWeights[i]",
 "patches": [
  "chiSquare += ((residual * residual) / residualsWeights[i])",
  "chiSquare += ((residual * residual) / jacobian)",
  "chiSquare += ((residual * residual) / targetValues)",
  "chiSquare += ((residual * residual) / residualsWeights)",
  "chiSquare += ((residual * residual) / point)",
  "chiSquare += ((residual * residual) / objective)",
  "chiSquare += ((residual * residual) / residuals)",
  "chiSquare += ((residual * residual) / cost)",
  "chiSquare += ((residual * residual) / jacobian[i])",
  "chiSquare += ((residual * residual) / targetValues[i])",
  "chiSquare += ((residual * residual) / point[i])",
  "chiSquare += ((residual * residual) / objective[i])",
  "chiSquare += ((residual * residual) / residuals[i])",
  "chiSquare += ((residual * residual) / cost[i])",
  "chiSquare = ((residual * residual) / residualsWeights[i])",
  "chiSquare -= ((residual * residual) / residualsWeights[i])",
  "chiSquare *= ((residual * residual) / residualsWeights[i])",
  "chiSquare += ((residual * residual) / residual)",
  "chiSquare += ((residual * residual) / i[i])",
  "chiSquare += (residual * residual)",
  "chiSquare += ((residual * residual) / residualsWeights[((residual * residual) / residualsWeights[i])])",
  "chiSquare += ((residual * residual) / i)",
  "chiSquare += ((residual * residual) / rows)",
  "",
  "chiSquare += residualsWeights[i]",
  "chiSquare += ((residual * residual) - residualsWeights[i])",
  "chiSquare += ((residual * residual) / jacobian.residualsWeights)",
  "chiSquare += ((residual * residual) / targetValues.residualsWeights)",
  "chiSquare += ((residual * residual) / residualsWeights.residualsWeights)",
  "chiSquare += ((residual * residual) / point.residualsWeights)",
  "chiSquare += ((residual * residual) / objective.residualsWeights)",
  "chiSquare += ((residual * residual) / residuals.residualsWeights)",
  "chiSquare += ((residual * residual) / cost.residualsWeights)",
  "chiSquare += ((residual * residual) / getRMS().residualsWeights)",
  "chiSquare += ((residual * residual) / getChiSquare().residualsWeights)",
  "chiSquare += ((residual * residual) / getCovariances().residualsWeights)",
  "chiSquare += ((residual * residual) / guessParametersErrors().residualsWeights)",
  "chiSquare += residualsWeights",
  "chiSquare += ((residual * residual) / rows[i])",
  "chiSquare += ((residual * residual) / chiSquare[i])",
  "chiSquare |= ((residual * residual) / residualsWeights[i])",
  "chiSquare &= ((residual * residual) / residualsWeights[i])",
  "chiSquare += ((residual * residual) / chiSquare)",
  "chiSquare += ((residual - residual) / residualsWeights[i])",
  "chiSquare += ((residual * residual) * residualsWeights)",
  "chiSquare += ((residual * residual) / residual[i])",
  "chiSquare += ((residual * residual) / residualsWeights[1])",
  "chiSquare += ((residual * residual) * residualsWeights[i])",
  "chiSquare += ((residual * residual) / -residualsWeights)",
  "return residualsWeights[i]",
  "chiSquare -= (residual * residual)",
  "chiSquare += ((residual * residual) / residualsWeights[jacobian])",
  "chiSquare += ((residual * residual) / residualsWeights[targetValues])",
  "chiSquare += ((residual * residual) / residualsWeights[residualsWeights])",
  "chiSquare += ((residual * residual) / residualsWeights[point])",
  "chiSquare += ((residual * residual) / residualsWeights[objective])",
  "chiSquare += ((residual * residual) / residualsWeights[residuals])",
  "chiSquare += ((residual * residual) / residualsWeights[cost])",
  "chiSquare += ((residual * residual) / residualsWeights[0])",
  "chiSquare += ((residual * residual) / residualsWeights[residual])",
  "chiSquare = (residual * residual)",
  "chiSquare += ((residual * residual) / residualsWeights[(residual * residual)])",
  "chiSquare += ((residual * residual) / jacobian.residualsWeights[i])",
  "chiSquare += ((residual * residual) / targetValues.residualsWeights[i])",
  "chiSquare += ((residual * residual) / residualsWeights.residualsWeights[i])",
  "chiSquare += ((residual * residual) / point.residualsWeights[i])",
  "chiSquare += ((residual * residual) / objective.residualsWeights[i])",
  "chiSquare += ((residual * residual) / residuals.residualsWeights[i])",
  "chiSquare += ((residual * residual) / cost.residualsWeights[i])",
  "chiSquare += ((residual * residual) / getRMS().residualsWeights[i])",
  "chiSquare += ((residual * residual) / getChiSquare().residualsWeights[i])",
  "chiSquare += ((residual * residual) / getCovariances().residualsWeights[i])",
  "chiSquare += ((residual * residual) / guessParametersErrors().residualsWeights[i])",
  "chiSquare += ((residual * residual) + residualsWeights)"
 ]
}